import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import fs from 'node:fs';
import path from 'node:path';

const execAsync = promisify(exec);

// Schema for vulnerability information
const vulnerabilitySchema = z.object({
  id: z.string().describe('Vulnerability ID (e.g., GO-2023-1234)'),
  summary: z.string().describe('Brief summary of the vulnerability'),
  description: z.string().describe('Detailed description of the vulnerability'),
  cve: z.array(z.string()).describe('Associated CVE identifiers'),
  severity: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL', 'UNKNOWN']).describe('Vulnerability severity'),
  affected: z.object({
    module: z.string().describe('Affected module path'),
    versions: z.string().describe('Affected version range'),
    vulnerableAt: z.string().optional().describe('Specific vulnerable version'),
    importedBy: z.array(z.string()).describe('Modules that import this vulnerable module'),
  }),
  fixed: z.object({
    version: z.string().optional().describe('Version that fixes the vulnerability'),
    recommendation: z.string().describe('Recommended action to fix'),
  }),
  references: z.array(z.string()).describe('Reference URLs for more information'),
});

const scanResultSchema = z.object({
  projectPath: z.string().describe('Path to the scanned project'),
  scanTimestamp: z.string().describe('When the scan was performed'),
  govulncheckAvailable: z.boolean().describe('Whether govulncheck tool is available'),
  govulncheckVersion: z.string().nullable().describe('Version of govulncheck used'),
  scanMode: z.enum(['binary', 'source', 'modules']).describe('Mode used for scanning'),
  vulnerabilities: z.array(vulnerabilitySchema).describe('Found vulnerabilities'),
  affectedModules: z.array(z.object({
    module: z.string(),
    version: z.string(),
    vulnerabilityCount: z.number(),
    severityBreakdown: z.object({
      critical: z.number(),
      high: z.number(),
      medium: z.number(),
      low: z.number(),
      unknown: z.number(),
    }),
  })).describe('Summary of affected modules'),
  summary: z.object({
    totalVulnerabilities: z.number(),
    criticalCount: z.number(),
    highCount: z.number(),
    mediumCount: z.number(),
    lowCount: z.number(),
    unknownCount: z.number(),
    affectedModuleCount: z.number(),
  }).describe('Summary statistics'),
  recommendations: z.array(z.string()).describe('Recommendations to address vulnerabilities'),
  rawOutput: z.string().describe('Raw govulncheck output for debugging'),
});

export type VulnerabilityInfo = z.infer<typeof vulnerabilitySchema>;
export type GoVulnerabilityScanResult = z.infer<typeof scanResultSchema>;

/**
 * Tool for scanning Go projects for security vulnerabilities using govulncheck
 */
export const goVulnerabilityScannerTool = createTool({
  id: 'go-vulnerability-scanner',
  description: 'Scans Go projects for security vulnerabilities using govulncheck and the Go vulnerability database',
  inputSchema: z.object({
    projectPath: z.string().describe('Path to the Go project directory to scan').optional(),
    scanMode: z.enum(['auto', 'binary', 'source', 'modules']).describe('Scan mode (auto will choose best mode)').optional(),
    binaryPath: z.string().describe('Path to Go binary to scan (required for binary mode)').optional(),
    installGovulncheck: z.boolean().describe('Whether to attempt installing govulncheck if not found').optional(),
    timeout: z.number().describe('Timeout in milliseconds for the scan (default: 60000)').optional(),
  }),
  outputSchema: scanResultSchema,
  execute: async ({ context }) => {
    const {
      projectPath = process.cwd(),
      scanMode = 'auto',
      binaryPath,
      installGovulncheck = true,
      timeout = 60000,
    } = context;

    const resolvedPath = path.resolve(projectPath);

    if (!fs.existsSync(resolvedPath)) {
      throw new Error(`Project path does not exist: ${resolvedPath}`);
    }

    const result: GoVulnerabilityScanResult = {
      projectPath: resolvedPath,
      scanTimestamp: new Date().toISOString(),
      govulncheckAvailable: false,
      govulncheckVersion: null,
      scanMode: 'source',
      vulnerabilities: [],
      affectedModules: [],
      summary: {
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        unknownCount: 0,
        affectedModuleCount: 0,
      },
      recommendations: [],
      rawOutput: '',
    };

    try {
      // 1. Check if govulncheck is available
      const govulncheckInfo = await checkGovulncheckAvailability();
      result.govulncheckAvailable = govulncheckInfo.available;
      result.govulncheckVersion = govulncheckInfo.version;

      // 2. Install govulncheck if not available and requested
      if (!result.govulncheckAvailable && installGovulncheck) {
        await installGovulncheckTool();
        const recheck = await checkGovulncheckAvailability();
        result.govulncheckAvailable = recheck.available;
        result.govulncheckVersion = recheck.version;
      }

      if (!result.govulncheckAvailable) {
        throw new Error('govulncheck tool is not available. Install it with: go install golang.org/x/vuln/cmd/govulncheck@latest');
      }

      // 3. Determine scan mode
      const actualScanMode = determineScanMode(scanMode, resolvedPath, binaryPath);
      result.scanMode = actualScanMode;

      // 4. Run govulncheck
      const scanOutput = await runGovulncheck(resolvedPath, actualScanMode, binaryPath, timeout);
      result.rawOutput = scanOutput;

      // 5. Parse vulnerabilities from output
      const parsedVulns = parseGovulncheckOutput(scanOutput);
      result.vulnerabilities = parsedVulns;

      // 6. Generate summary and affected modules
      generateSummary(result);
      generateAffectedModules(result);

      // 7. Generate recommendations
      result.recommendations = generateRecommendations(result);

      return result;
    } catch (error) {
      throw new Error(`Failed to scan for vulnerabilities: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
});

/**
 * Check if govulncheck is available and get its version
 */
async function checkGovulncheckAvailability(): Promise<{ available: boolean; version: string | null }> {
  try {
    const { stdout } = await execAsync('govulncheck -version', { timeout: 5000 });
    const version = stdout.trim();
    return { available: true, version };
  } catch (error) {
    return { available: false, version: null };
  }
}

/**
 * Install govulncheck tool
 */
async function installGovulncheckTool(): Promise<void> {
  try {
    await execAsync('go install golang.org/x/vuln/cmd/govulncheck@latest', { timeout: 30000 });
  } catch (error) {
    throw new Error(`Failed to install govulncheck: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Determine the best scan mode to use
 */
function determineScanMode(
  requestedMode: string,
  projectPath: string,
  binaryPath?: string,
): 'binary' | 'source' | 'modules' {
  if (requestedMode !== 'auto') {
    return requestedMode as 'binary' | 'source' | 'modules';
  }

  // If binary path is provided, use binary mode
  if (binaryPath && fs.existsSync(binaryPath)) {
    return 'binary';
  }

  // If go.mod exists, use source mode
  if (fs.existsSync(path.join(projectPath, 'go.mod'))) {
    return 'source';
  }

  // Fallback to modules mode
  return 'modules';
}

/**
 * Run govulncheck with the specified mode
 */
async function runGovulncheck(
  projectPath: string,
  scanMode: 'binary' | 'source' | 'modules',
  binaryPath?: string,
  timeout = 60000,
): Promise<string> {
  let command: string;
  const options = { cwd: projectPath, timeout };

  switch (scanMode) {
    case 'binary':
      if (!binaryPath) {
        throw new Error('Binary path is required for binary scan mode');
      }
      command = `govulncheck -json ${binaryPath}`;
      break;
    case 'source':
      command = 'govulncheck -json ./...';
      break;
    case 'modules':
      command = 'govulncheck -json -mode=modules ./...';
      break;
    default:
      throw new Error(`Unknown scan mode: ${scanMode}`);
  }

  try {
    const { stdout, stderr } = await execAsync(command, options);
    // govulncheck may output to stderr even on success, so combine both
    return stdout + (stderr ? '\n' + stderr : '');
  } catch (error) {
    // govulncheck exits with non-zero when vulnerabilities are found
    // So we need to capture the output even on "error"
    if (error instanceof Error && 'stdout' in error) {
      const execError = error as any;
      return execError.stdout + (execError.stderr ? '\n' + execError.stderr : '');
    }
    throw error;
  }
}

/**
 * Parse govulncheck JSON output
 */
function parseGovulncheckOutput(output: string): VulnerabilityInfo[] {
  const vulnerabilities: VulnerabilityInfo[] = [];
  const lines = output.split('\n').filter(line => line.trim());

  for (const line of lines) {
    try {
      const parsed = JSON.parse(line);

      // Look for vulnerability findings
      if (parsed.finding && parsed.finding.osv) {
        const osv = parsed.finding.osv;
        const trace = parsed.finding.trace || [];

        const vuln: VulnerabilityInfo = {
          id: osv.id || 'UNKNOWN',
          summary: osv.summary || 'No summary available',
          description: osv.details || osv.summary || 'No description available',
          cve: osv.aliases?.filter((alias: string) => alias.startsWith('CVE-')) || [],
          severity: mapSeverity(osv.database_specific?.severity || osv.severity),
          affected: {
            module: extractModulePath(trace),
            versions: formatAffectedVersions(osv.affected || []),
            vulnerableAt: extractVulnerableVersion(osv.affected || []),
            importedBy: extractImportedBy(trace),
          },
          fixed: {
            version: extractFixedVersion(osv.affected || []),
            recommendation: generateFixRecommendation(osv),
          },
          references: osv.references?.map((ref: any) => ref.url).filter(Boolean) || [],
        };

        vulnerabilities.push(vuln);
      }
    } catch (error) {
      // Skip lines that aren't valid JSON
      continue;
    }
  }

  return vulnerabilities;
}

/**
 * Map severity from various formats to our standard format
 */
function mapSeverity(severity: string | undefined): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' | 'UNKNOWN' {
  if (!severity) return 'UNKNOWN';

  const sev = severity.toUpperCase();
  if (sev.includes('CRITICAL')) return 'CRITICAL';
  if (sev.includes('HIGH')) return 'HIGH';
  if (sev.includes('MEDIUM') || sev.includes('MODERATE')) return 'MEDIUM';
  if (sev.includes('LOW')) return 'LOW';

  return 'UNKNOWN';
}

/**
 * Extract module path from trace information
 */
function extractModulePath(trace: any[]): string {
  if (!Array.isArray(trace) || trace.length === 0) {
    return 'unknown';
  }

  // Look for module information in the trace
  for (const item of trace) {
    if (item.module) {
      return item.module;
    }
  }

  return 'unknown';
}

/**
 * Format affected versions from OSV data
 */
function formatAffectedVersions(affected: any[]): string {
  if (!Array.isArray(affected) || affected.length === 0) {
    return 'unknown';
  }

  const ranges = affected
    .flatMap(item => item.ranges || [])
    .map((range: any) => {
      if (range.type === 'SEMVER') {
        const events = range.events || [];
        const introduced = events.find((e: any) => e.introduced)?.introduced || '0';
        const fixed = events.find((e: any) => e.fixed)?.fixed;
        
        if (fixed) {
          return `${introduced} - ${fixed}`;
        } else {
          return `>= ${introduced}`;
        }
      }
      return null;
    })
    .filter(Boolean);

  return ranges.length > 0 ? ranges.join(', ') : 'unknown';
}

/**
 * Extract vulnerable version from affected data
 */
function extractVulnerableVersion(affected: any[]): string | undefined {
  if (!Array.isArray(affected) || affected.length === 0) {
    return undefined;
  }

  // Try to find a specific vulnerable version
  for (const item of affected) {
    if (item.versions && Array.isArray(item.versions)) {
      return item.versions[0];
    }
  }

  return undefined;
}

/**
 * Extract modules that import the vulnerable module
 */
function extractImportedBy(trace: any[]): string[] {
  if (!Array.isArray(trace)) {
    return [];
  }

  const importers = new Set<string>();
  
  for (const item of trace) {
    if (item.module && item.module !== extractModulePath(trace)) {
      importers.add(item.module);
    }
  }

  return Array.from(importers);
}

/**
 * Extract fixed version from affected data
 */
function extractFixedVersion(affected: any[]): string | undefined {
  if (!Array.isArray(affected) || affected.length === 0) {
    return undefined;
  }

  for (const item of affected) {
    const ranges = item.ranges || [];
    for (const range of ranges) {
      const events = range.events || [];
      const fixed = events.find((e: any) => e.fixed)?.fixed;
      if (fixed) {
        return fixed;
      }
    }
  }

  return undefined;
}

/**
 * Generate fix recommendation for a vulnerability
 */
function generateFixRecommendation(osv: any): string {
  const fixedVersion = extractFixedVersion(osv.affected || []);
  
  if (fixedVersion) {
    return `Upgrade to version ${fixedVersion} or later`;
  }

  return 'Review the vulnerability details and update to a safe version';
}

/**
 * Generate summary statistics
 */
function generateSummary(result: GoVulnerabilityScanResult): void {
  const summary = result.summary;
  
  summary.totalVulnerabilities = result.vulnerabilities.length;
  
  for (const vuln of result.vulnerabilities) {
    switch (vuln.severity) {
      case 'CRITICAL':
        summary.criticalCount++;
        break;
      case 'HIGH':
        summary.highCount++;
        break;
      case 'MEDIUM':
        summary.mediumCount++;
        break;
      case 'LOW':
        summary.lowCount++;
        break;
      case 'UNKNOWN':
        summary.unknownCount++;
        break;
    }
  }

  // Count unique affected modules
  const affectedModules = new Set(result.vulnerabilities.map(v => v.affected.module));
  summary.affectedModuleCount = affectedModules.size;
}

/**
 * Generate affected modules summary
 */
function generateAffectedModules(result: GoVulnerabilityScanResult): void {
  const moduleMap = new Map<string, {
    vulnerabilities: VulnerabilityInfo[];
    version: string;
  }>();

  // Group vulnerabilities by module
  for (const vuln of result.vulnerabilities) {
    const module = vuln.affected.module;
    if (!moduleMap.has(module)) {
      moduleMap.set(module, {
        vulnerabilities: [],
        version: vuln.affected.vulnerableAt || 'unknown',
      });
    }
    moduleMap.get(module)!.vulnerabilities.push(vuln);
  }

  // Create affected modules summary
  result.affectedModules = Array.from(moduleMap.entries()).map(([module, data]) => {
    const severityBreakdown = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      unknown: 0,
    };

    for (const vuln of data.vulnerabilities) {
      switch (vuln.severity) {
        case 'CRITICAL':
          severityBreakdown.critical++;
          break;
        case 'HIGH':
          severityBreakdown.high++;
          break;
        case 'MEDIUM':
          severityBreakdown.medium++;
          break;
        case 'LOW':
          severityBreakdown.low++;
          break;
        case 'UNKNOWN':
          severityBreakdown.unknown++;
          break;
      }
    }

    return {
      module,
      version: data.version,
      vulnerabilityCount: data.vulnerabilities.length,
      severityBreakdown,
    };
  });
}

/**
 * Generate recommendations based on scan results
 */
function generateRecommendations(result: GoVulnerabilityScanResult): string[] {
  const recommendations: string[] = [];

  if (result.summary.totalVulnerabilities === 0) {
    recommendations.push('No vulnerabilities found. Keep dependencies updated and scan regularly.');
    return recommendations;
  }

  // Critical and high severity recommendations
  if (result.summary.criticalCount > 0) {
    recommendations.push(`URGENT: Address ${result.summary.criticalCount} critical vulnerabilities immediately.`);
  }

  if (result.summary.highCount > 0) {
    recommendations.push(`High priority: Address ${result.summary.highCount} high-severity vulnerabilities.`);
  }

  // Module-specific recommendations
  const modulesToUpdate = result.affectedModules
    .filter(m => m.severityBreakdown.critical > 0 || m.severityBreakdown.high > 0)
    .slice(0, 5); // Limit to top 5

  if (modulesToUpdate.length > 0) {
    recommendations.push(`Update these critical modules: ${modulesToUpdate.map(m => m.module).join(', ')}`);
  }

  // General recommendations
  recommendations.push('Run `go mod tidy` and `go get -u` to update dependencies to latest versions.');
  recommendations.push('Consider using `go get -u=patch` for safer patch-level updates only.');
  recommendations.push('Set up automated vulnerability scanning in your CI/CD pipeline.');

  if (result.summary.mediumCount > 0 || result.summary.lowCount > 0) {
    recommendations.push('Schedule time to address medium and low severity vulnerabilities.');
  }

  return recommendations;
}