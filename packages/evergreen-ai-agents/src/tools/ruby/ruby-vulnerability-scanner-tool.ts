import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import fs from 'node:fs';
import path from 'node:path';

const execAsync = promisify(exec);

// Schema for vulnerability information
const vulnerabilitySchema = z.object({
  gem: z.string().describe('Name of the vulnerable gem'),
  version: z.string().describe('Version of the gem with vulnerability'),
  advisory: z.string().describe('Advisory identifier (e.g., CVE, GHSA)'),
  title: z.string().describe('Vulnerability title/summary'),
  description: z.string().describe('Detailed description of the vulnerability'),
  severity: z.enum(['low', 'medium', 'high', 'critical']).describe('Severity level'),
  cvss: z.number().optional().describe('CVSS score if available'),
  patchedVersions: z.array(z.string()).describe('Versions that fix the vulnerability'),
  unaffectedVersions: z.array(z.string()).describe('Versions not affected by the vulnerability'),
  url: z.string().optional().describe('URL to advisory details'),
  publishedDate: z.string().optional().describe('Date the advisory was published'),
});

const scanResultSchema = z.object({
  projectPath: z.string().describe('Path to the scanned project'),
  scanTimestamp: z.string().describe('When the scan was performed'),
  scannerUsed: z.enum(['bundler-audit', 'ruby-advisory-db', 'manual']).describe('Scanner tool used'),
  totalGems: z.number().describe('Total number of gems scanned'),
  vulnerableGems: z.number().describe('Number of gems with vulnerabilities'),
  totalVulnerabilities: z.number().describe('Total number of vulnerabilities found'),
  vulnerabilities: z.array(vulnerabilitySchema).describe('Detailed vulnerability information'),
  criticalVulnerabilities: z.number().describe('Number of critical vulnerabilities'),
  highVulnerabilities: z.number().describe('Number of high severity vulnerabilities'),
  mediumVulnerabilities: z.number().describe('Number of medium severity vulnerabilities'),
  lowVulnerabilities: z.number().describe('Number of low severity vulnerabilities'),
  recommendations: z.array(z.string()).describe('Security recommendations'),
  updateCommands: z.array(z.string()).describe('Commands to update vulnerable gems'),
  riskAssessment: z.object({
    overallRisk: z.enum(['low', 'medium', 'high', 'critical']).describe('Overall security risk level'),
    factors: z.array(z.string()).describe('Factors contributing to risk assessment'),
    immediateActions: z.array(z.string()).describe('Actions that should be taken immediately'),
  }),
});

export type RubyVulnerabilityScan = z.infer<typeof scanResultSchema>;
export type RubyVulnerability = z.infer<typeof vulnerabilitySchema>;

/**
 * Tool for scanning Ruby projects for security vulnerabilities
 */
export const rubyVulnerabilityScannerTool = createTool({
  id: 'ruby-vulnerability-scanner',
  description: 'Scans Ruby projects for known security vulnerabilities using bundler-audit and Ruby Advisory Database',
  inputSchema: z.object({
    projectPath: z.string().describe('Path to the Ruby project directory to scan (default: current directory)').optional(),
    updateDatabase: z.boolean().describe('Whether to update the vulnerability database before scanning').optional(),
    includeInsecureSources: z.boolean().describe('Whether to check for insecure gem sources').optional(),
  }),
  outputSchema: scanResultSchema,
  execute: async ({ context }) => {
    const { 
      projectPath = process.cwd(), 
      updateDatabase = true,
      includeInsecureSources = true 
    } = context;

    const resolvedPath = path.resolve(projectPath);

    // Validate that the path exists
    if (!fs.existsSync(resolvedPath)) {
      throw new Error(`Project path does not exist: ${resolvedPath}`);
    }

    // Check if this is a Ruby project
    const gemfilePath = path.join(resolvedPath, 'Gemfile');
    if (!fs.existsSync(gemfilePath)) {
      throw new Error(`No Gemfile found in project path: ${resolvedPath}`);
    }

    let scannerUsed: 'bundler-audit' | 'ruby-advisory-db' | 'manual' = 'manual';
    let vulnerabilities: RubyVulnerability[] = [];
    let totalGems = 0;

    try {
      // Try to use bundler-audit first
      try {
        const result = await runBundlerAudit(resolvedPath, updateDatabase, includeInsecureSources);
        vulnerabilities = result.vulnerabilities;
        scannerUsed = 'bundler-audit';
        totalGems = result.totalGems;
      } catch (bundlerAuditError) {
        console.warn('bundler-audit not available, falling back to manual scanning');
        
        // Fallback to manual vulnerability checking
        const result = await performManualScan(resolvedPath);
        vulnerabilities = result.vulnerabilities;
        scannerUsed = 'manual';
        totalGems = result.totalGems;
      }

      // Count vulnerabilities by severity
      const criticalVulnerabilities = vulnerabilities.filter(v => v.severity === 'critical').length;
      const highVulnerabilities = vulnerabilities.filter(v => v.severity === 'high').length;
      const mediumVulnerabilities = vulnerabilities.filter(v => v.severity === 'medium').length;
      const lowVulnerabilities = vulnerabilities.filter(v => v.severity === 'low').length;

      // Generate recommendations and update commands
      const recommendations = generateSecurityRecommendations(vulnerabilities, scannerUsed);
      const updateCommands = generateUpdateCommands(vulnerabilities);

      // Assess overall risk
      const riskAssessment = assessSecurityRisk(vulnerabilities);

      return {
        projectPath: resolvedPath,
        scanTimestamp: new Date().toISOString(),
        scannerUsed,
        totalGems,
        vulnerableGems: new Set(vulnerabilities.map(v => v.gem)).size,
        totalVulnerabilities: vulnerabilities.length,
        vulnerabilities,
        criticalVulnerabilities,
        highVulnerabilities,
        mediumVulnerabilities,
        lowVulnerabilities,
        recommendations,
        updateCommands,
        riskAssessment,
      };
    } catch (error) {
      throw new Error(`Failed to scan for vulnerabilities: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
});

/**
 * Run bundler-audit to scan for vulnerabilities
 */
async function runBundlerAudit(projectPath: string, updateDatabase: boolean, includeInsecureSources: boolean) {
  const vulnerabilities: RubyVulnerability[] = [];
  let totalGems = 0;

  try {
    // Check if bundler-audit is installed
    await execAsync('bundle audit --version', { cwd: projectPath });
  } catch {
    throw new Error('bundler-audit is not installed or available');
  }

  try {
    // Update the vulnerability database
    if (updateDatabase) {
      await execAsync('bundle audit update', { cwd: projectPath });
    }

    // Run bundler audit
    let auditCommand = 'bundle audit check';
    if (includeInsecureSources) {
      auditCommand += ' --insecure';
    }

    const { stdout, stderr } = await execAsync(auditCommand, { cwd: projectPath });

    // Parse bundler-audit output
    const output = stdout + stderr;
    vulnerabilities.push(...parseBundlerAuditOutput(output));

    // Get total gem count from Gemfile.lock
    totalGems = await getTotalGemCount(projectPath);

  } catch (error: any) {
    // bundler-audit returns non-zero exit code when vulnerabilities are found
    if (error.code === 1 && error.stdout) {
      // Parse the output even when exit code is 1
      vulnerabilities.push(...parseBundlerAuditOutput(error.stdout + (error.stderr || '')));
      totalGems = await getTotalGemCount(projectPath);
    } else {
      throw error;
    }
  }

  return { vulnerabilities, totalGems };
}

/**
 * Parse bundler-audit output to extract vulnerability information
 */
function parseBundlerAuditOutput(output: string): RubyVulnerability[] {
  const vulnerabilities: RubyVulnerability[] = [];
  const lines = output.split('\n');
  
  let currentVuln: Partial<RubyVulnerability> = {};
  let parsingVuln = false;

  for (const line of lines) {
    const trimmed = line.trim();
    
    // Start of a new vulnerability
    if (trimmed.startsWith('Name:')) {
      if (parsingVuln && currentVuln.gem) {
        vulnerabilities.push(currentVuln as RubyVulnerability);
      }
      currentVuln = {};
      parsingVuln = true;
      currentVuln.gem = trimmed.replace('Name:', '').trim();
    }
    
    if (parsingVuln) {
      if (trimmed.startsWith('Version:')) {
        currentVuln.version = trimmed.replace('Version:', '').trim();
      } else if (trimmed.startsWith('Advisory:')) {
        currentVuln.advisory = trimmed.replace('Advisory:', '').trim();
      } else if (trimmed.startsWith('Title:')) {
        currentVuln.title = trimmed.replace('Title:', '').trim();
      } else if (trimmed.startsWith('URL:')) {
        currentVuln.url = trimmed.replace('URL:', '').trim();
      } else if (trimmed.startsWith('Patched Versions:')) {
        const patchedText = trimmed.replace('Patched Versions:', '').trim();
        currentVuln.patchedVersions = patchedText.split(',').map(v => v.trim()).filter(Boolean);
      } else if (trimmed.startsWith('Unaffected Versions:')) {
        const unaffectedText = trimmed.replace('Unaffected Versions:', '').trim();
        currentVuln.unaffectedVersions = unaffectedText.split(',').map(v => v.trim()).filter(Boolean);
      }
    }
  }
  
  // Add the last vulnerability
  if (parsingVuln && currentVuln.gem) {
    vulnerabilities.push(currentVuln as RubyVulnerability);
  }

  // Fill in missing fields with defaults
  return vulnerabilities.map(vuln => ({
    gem: vuln.gem || 'unknown',
    version: vuln.version || 'unknown',
    advisory: vuln.advisory || 'unknown',
    title: vuln.title || 'Security vulnerability',
    description: vuln.title || 'Security vulnerability detected',
    severity: determineSeverityFromAdvisory(vuln.advisory || ''),
    patchedVersions: vuln.patchedVersions || [],
    unaffectedVersions: vuln.unaffectedVersions || [],
    url: vuln.url,
  }));
}

/**
 * Determine severity from advisory ID
 */
function determineSeverityFromAdvisory(advisory: string): 'low' | 'medium' | 'high' | 'critical' {
  if (advisory.startsWith('CVE-')) {
    // For CVE, we'd need to look up CVSS scores, defaulting to medium
    return 'medium';
  } else if (advisory.startsWith('GHSA-')) {
    // GitHub Security Advisory, defaulting to high
    return 'high';
  } else if (advisory.includes('critical')) {
    return 'critical';
  } else if (advisory.includes('high')) {
    return 'high';
  } else if (advisory.includes('low')) {
    return 'low';
  }
  
  return 'medium'; // Default severity
}

/**
 * Get total gem count from Gemfile.lock
 */
async function getTotalGemCount(projectPath: string): Promise<number> {
  const lockfilePath = path.join(projectPath, 'Gemfile.lock');
  
  if (!fs.existsSync(lockfilePath)) {
    return 0;
  }

  try {
    const content = fs.readFileSync(lockfilePath, 'utf8');
    const lines = content.split('\n');
    let gemCount = 0;
    let inGemSection = false;

    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed === 'GEM') {
        inGemSection = true;
        continue;
      }
      
      if (inGemSection && trimmed === '') {
        break;
      }
      
      if (inGemSection && line.startsWith('    ') && !line.startsWith('      ')) {
        // This is a gem line (4 spaces indent)
        gemCount++;
      }
    }

    return gemCount;
  } catch {
    return 0;
  }
}

/**
 * Perform manual vulnerability scanning using known patterns
 */
async function performManualScan(projectPath: string) {
  const vulnerabilities: RubyVulnerability[] = [];
  let totalGems = 0;

  try {
    // Get gems from Gemfile.lock
    const gems = await parseGemfileForVulnScanning(projectPath);
    totalGems = gems.length;

    // Check for known vulnerable gems/versions
    for (const gem of gems) {
      const vulns = checkKnownVulnerabilities(gem.name, gem.version);
      vulnerabilities.push(...vulns);
    }

    // Check for insecure sources
    const insecureSourceVulns = await checkInsecureSources(projectPath);
    vulnerabilities.push(...insecureSourceVulns);

  } catch (error) {
    console.warn('Manual vulnerability scanning failed:', error);
  }

  return { vulnerabilities, totalGems };
}

/**
 * Parse Gemfile.lock to get gem information
 */
async function parseGemfileForVulnScanning(projectPath: string) {
  const gems: { name: string; version: string }[] = [];
  const lockfilePath = path.join(projectPath, 'Gemfile.lock');
  
  if (!fs.existsSync(lockfilePath)) {
    return gems;
  }

  try {
    const content = fs.readFileSync(lockfilePath, 'utf8');
    const lines = content.split('\n');
    let inGemSection = false;

    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed === 'GEM') {
        inGemSection = true;
        continue;
      }
      
      if (inGemSection && trimmed === '') {
        break;
      }
      
      if (inGemSection && line.startsWith('    ') && !line.startsWith('      ')) {
        // Parse gem line: "    gemname (version)"
        const match = trimmed.match(/^([a-zA-Z0-9_-]+)\s+\(([^)]+)\)$/);
        if (match) {
          gems.push({
            name: match[1],
            version: match[2],
          });
        }
      }
    }
  } catch {
    // Ignore parsing errors
  }

  return gems;
}

/**
 * Check for known vulnerabilities in specific gem versions
 */
function checkKnownVulnerabilities(gemName: string, version: string): RubyVulnerability[] {
  const vulnerabilities: RubyVulnerability[] = [];

  // This would ideally query a vulnerability database
  // For now, we'll include some common high-profile vulnerabilities
  const knownVulns: Record<string, Array<{
    versions: string[];
    advisory: string;
    title: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    patchedVersions: string[];
  }>> = {
    'rails': [
      {
        versions: ['< 6.1.7.3', '< 7.0.4.3'],
        advisory: 'CVE-2023-27539',
        title: 'Possible XSS vulnerability in Action View tag helpers',
        severity: 'high',
        patchedVersions: ['>= 6.1.7.3', '>= 7.0.4.3'],
      }
    ],
    'nokogiri': [
      {
        versions: ['< 1.13.10'],
        advisory: 'CVE-2022-23437',
        title: 'XML External Entity vulnerability in Nokogiri',
        severity: 'high',
        patchedVersions: ['>= 1.13.10'],
      }
    ],
    'actionpack': [
      {
        versions: ['< 6.1.7.2', '>= 7.0.0, < 7.0.4.2'],
        advisory: 'CVE-2023-22792',
        title: 'ReDoS based DoS vulnerability in Action Dispatch',
        severity: 'medium',
        patchedVersions: ['>= 6.1.7.2', '>= 7.0.4.2'],
      }
    ]
  };

  const gemVulns = knownVulns[gemName];
  if (gemVulns) {
    for (const vuln of gemVulns) {
      if (isVersionVulnerable(version, vuln.versions)) {
        vulnerabilities.push({
          gem: gemName,
          version,
          advisory: vuln.advisory,
          title: vuln.title,
          description: vuln.title,
          severity: vuln.severity,
          patchedVersions: vuln.patchedVersions,
          unaffectedVersions: [],
        });
      }
    }
  }

  return vulnerabilities;
}

/**
 * Check if a version matches vulnerability criteria
 */
function isVersionVulnerable(version: string, vulnerableVersions: string[]): boolean {
  // This is a simplified version check
  // In a real implementation, you'd use a proper semver library
  for (const vulnVersion of vulnerableVersions) {
    if (vulnVersion.includes('<') && vulnVersion.includes(version)) {
      return true;
    }
  }
  return false;
}

/**
 * Check for insecure gem sources
 */
async function checkInsecureSources(projectPath: string): Promise<RubyVulnerability[]> {
  const vulnerabilities: RubyVulnerability[] = [];
  const gemfilePath = path.join(projectPath, 'Gemfile');
  
  if (!fs.existsSync(gemfilePath)) {
    return vulnerabilities;
  }

  try {
    const content = fs.readFileSync(gemfilePath, 'utf8');
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const sourceMatch = line.match(/^\s*source\s+['"]([^'"]+)['"]/);
      
      if (sourceMatch) {
        const source = sourceMatch[1];
        
        if (source.startsWith('http://')) {
          vulnerabilities.push({
            gem: 'source-configuration',
            version: '0.0.0',
            advisory: 'INSECURE-SOURCE',
            title: 'Insecure gem source using HTTP',
            description: `Insecure HTTP source found: ${source}. This could allow man-in-the-middle attacks.`,
            severity: 'medium',
            patchedVersions: ['Use HTTPS sources'],
            unaffectedVersions: [],
            publishedDate: new Date().toISOString(),
          });
        }
      }
    }
  } catch {
    // Ignore parsing errors
  }

  return vulnerabilities;
}

/**
 * Generate security recommendations based on vulnerabilities found
 */
function generateSecurityRecommendations(vulnerabilities: RubyVulnerability[], scannerUsed: string): string[] {
  const recommendations: string[] = [];

  if (vulnerabilities.length === 0) {
    recommendations.push('No known vulnerabilities found. Keep gems updated and run regular security scans.');
    if (scannerUsed === 'manual') {
      recommendations.push('Install bundler-audit for more comprehensive vulnerability scanning: gem install bundler-audit');
    }
    return recommendations;
  }

  // Critical vulnerabilities
  const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
  if (criticalVulns.length > 0) {
    recommendations.push(`URGENT: ${criticalVulns.length} critical vulnerabilities found. Update immediately.`);
  }

  // High severity vulnerabilities
  const highVulns = vulnerabilities.filter(v => v.severity === 'high');
  if (highVulns.length > 0) {
    recommendations.push(`${highVulns.length} high severity vulnerabilities found. Update as soon as possible.`);
  }

  // General recommendations
  recommendations.push('Review and update vulnerable gems to patched versions');
  recommendations.push('Test thoroughly after updating gems to ensure compatibility');
  recommendations.push('Consider setting up automated vulnerability scanning in CI/CD pipeline');
  
  if (scannerUsed === 'manual') {
    recommendations.push('Install bundler-audit for automated vulnerability scanning: gem install bundler-audit');
  }

  // Source security
  const sourceVulns = vulnerabilities.filter(v => v.gem === 'source-configuration');
  if (sourceVulns.length > 0) {
    recommendations.push('Update Gemfile to use HTTPS sources only (https://rubygems.org)');
  }

  return recommendations;
}

/**
 * Generate update commands for vulnerable gems
 */
function generateUpdateCommands(vulnerabilities: RubyVulnerability[]): string[] {
  const commands: string[] = [];
  const uniqueGems = new Set<string>();

  for (const vuln of vulnerabilities) {
    if (vuln.gem !== 'source-configuration' && !uniqueGems.has(vuln.gem)) {
      uniqueGems.add(vuln.gem);
      
      if (vuln.patchedVersions.length > 0) {
        const patchedVersion = vuln.patchedVersions[0];
        commands.push(`bundle update ${vuln.gem} # Update to ${patchedVersion}`);
      } else {
        commands.push(`bundle update ${vuln.gem} # Update to latest version`);
      }
    }
  }

  if (commands.length > 0) {
    commands.unshift('# Update vulnerable gems:');
    commands.push('bundle install # Install updated gems');
  }

  return commands;
}

/**
 * Assess overall security risk based on vulnerabilities
 */
function assessSecurityRisk(vulnerabilities: RubyVulnerability[]): {
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  factors: string[];
  immediateActions: string[];
} {
  const factors: string[] = [];
  const immediateActions: string[] = [];

  if (vulnerabilities.length === 0) {
    return {
      overallRisk: 'low',
      factors: ['No known vulnerabilities detected'],
      immediateActions: ['Continue regular security monitoring'],
    };
  }

  const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
  const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
  const mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;

  let overallRisk: 'low' | 'medium' | 'high' | 'critical' = 'low';

  if (criticalCount > 0) {
    overallRisk = 'critical';
    factors.push(`${criticalCount} critical severity vulnerabilities`);
    immediateActions.push('Update critical vulnerabilities immediately');
    immediateActions.push('Consider taking application offline until critical issues are resolved');
  }

  if (highCount > 0) {
    if (overallRisk !== 'critical') {
      overallRisk = 'high';
    }
    factors.push(`${highCount} high severity vulnerabilities`);
    immediateActions.push('Schedule urgent maintenance window to address high severity issues');
  }

  if (mediumCount > 0) {
    if (overallRisk === 'low') {
      overallRisk = 'medium';
    }
    factors.push(`${mediumCount} medium severity vulnerabilities`);
    immediateActions.push('Plan updates for medium severity vulnerabilities within the week');
  }

  // Check for outdated gems
  const totalVulnGems = new Set(vulnerabilities.map(v => v.gem)).size;
  if (totalVulnGems > 5) {
    factors.push(`${totalVulnGems} gems with known vulnerabilities`);
    immediateActions.push('Conduct comprehensive gem audit and update strategy');
  }

  if (immediateActions.length === 0) {
    immediateActions.push('Review vulnerability details and plan updates');
  }

  return {
    overallRisk,
    factors,
    immediateActions,
  };
}